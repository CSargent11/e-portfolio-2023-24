<!DOCTYPE html>
<!--
	Prologue by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<style>
    .centered {
        display: flex;
        justify-content: center;
        align-items: center;
    }
</style>
	<head>
		<li><a href="index.html"><span class="icon solid fa-home">Home</span></a></li>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">
		</div>
<html>

<!-- Main -->

		<div id="main">

				<!-- Intro -->
					<section id="top" class="one dark cover">
						<div class="container">

<div>	
	<h2>Secure Software Development</br>
		Module 3</h2>
	</br>
<strong>Unit 1: Introduction to Secure Software Development</strong>
</br>
		<style>
	.fit-page {
  max-width: 100%;
  height: auto;}
	</style>
	<head>
    <p><b>Discussion post:</b></p>
</head>
<body>
    <img src="images/IP1.png" alt="Initial Post"class="fit-page">
	<img src="images/IP2.png" alt="Initial Post"class="fit-page">
		<img src="images/IP3.png" alt="Initial Post"class="fit-page">
</body>
<br/>
</br>
<strong>Unit 2: UML Modelling to Support Secure System Planning</strong>
</br>
</br>
		<style>
	.fit-page {
  max-width: 100%;
  height: auto;}
	</style>
	<head>
    <p><b>Peer responses:</b></p>
</head>
<body>
    <img src="images/PR1.png" alt="Peer Response"class="fit-page">
	<img src="images/PR2.png" alt="Peer Response"class="fit-page">
</body>
	</br>
	<b>Seminar activities:</b>
	</br>
	<i>Question 2: Blog Post (also e-portfolio activity)</i></br>
Some say that people are the biggest risk of cyber security.</br>
Five terms from ISO/IEC Standard 27000 Section 3 Terms and Definitions related to the topic of cyber security and the human factor:</br>
</br>
The cycle to help with continued improvement.</br>
P-plan </br>
D-do </br>
C-check	</br>
A-act </br>
</br>
These terms highlight the importance of considering the human factor in cyber security, including the role of users, the need for awareness and competence,
	the value of training, and the establishment of responsibilities and accountability within organisations.</br>

Dealing with the human factor in information security is crucial for establishing a robust security posture.</br>
	Here are some key measures and best practices to address the human factor:</br>
</br>
1. Security Awareness Training: Provide regular and comprehensive security awareness training to all employees.
	This should cover topics such as recognising phishing emails, identifying social engineering techniques, practicing strong password management,
	and adhering to security policies and procedures. Training should be engaging, relevant, and tailored to different roles and responsibilities
	within the organisation.</br>
</br>
2. Establish Security Policies and Procedures: Develop and communicate clear security policies and procedures that outline expected behaviours and
	responsibilities related to information security. These policies should cover areas such as acceptable use of technology, handling of sensitive data,
	access controls, incident reporting, and remote work security. Ensure that employees understand and adhere to these policies through regular reinforcement and reminders.</br>
</br>
3. Role-Based Access Controls: Implement role-based access controls (RBAC) to ensure that employees have access only to the resources and information necessary for their job functions.
	Regularly review and update access privileges based on changes in job roles or responsibilities. This helps minimise the risk of unauthorised access or data leakage.</br>
</br>
4. Incident Response and Reporting: Establish a clear incident response process and encourage employees to promptly report any security incidents, suspicious activities,
	or potential vulnerabilities they come across. Create a culture where reporting security concerns is encouraged and not met with punishment.
	This enables timely response and mitigation of security incidents before they escalate.</br>
</br>
5. Continuous Monitoring and Auditing: Implement systems for monitoring and auditing user activities, network traffic, and access logs to identify any unusual or suspicious behaviour.
	This can help detect and prevent security breaches caused by insiders or external threats that exploit human vulnerabilities.
	Regularly review and analyse monitoring and audit logs to identify potential risks or policy violations.</br>
</br>
6. Employee Engagement and Communication: Foster a culture of security within the organisation by engaging employees in security initiatives and decision-making processes.
	Encourage open communication channels where employees can ask questions, seek guidance, and report security concerns without fear of retribution.
	Regularly communicate security updates, best practices, and success stories to keep security top-of-mind for employees.</br>
</br>
7. Third-Party Management: Extend security considerations to third-party vendors and contractors who have access to your systems or data.
	Implement due diligence processes to assess the security practices of third-party entities and include security requirements in contracts and service level agreements.
	Regularly review and monitor their compliance with security standards.</br>
</br>
By implementing these measures, organisations can effectively address the human factor in information security and minimise the risk of security breaches caused by human error,
	social engineering, or insider threats. It is important to continuously evaluate and update these measures to keep pace with evolving security threats and industry best practices.
</br>
</br>
<strong>Unit 3: Programming Languages: History, Concepts & Design</strong></br>
</br>
<b>Team discussion:</b>
</br>
	</br>
We had to read chapters 2,6,7,8 of the course text (Pillai, 2017) and Cifuentes & Bierman (2019) and then answer the questions below.
</br>
1. What factors determine whether a programming language is secure or not?</br>
	2.	Could Python be classed as a secure language? Justify your answer.</br>
	3.	Python would be a better language to create operating systems than C. Discuss.</br>
</br>
	Within our team we each answered the questions sepeartely, then shared our answers in our group discussion forum.</br>
	Once we had all read one anothers, we then discussed similiarties and differences we had in our answers.</br>
	We all agreed, in the end that C is a more secure programming language compared to Python but that fundamentaly
	most security comes down to the programmer and their skills not the software.</br>
	</br>

	<b>Codio labs:</b>
	</br>
	<i>Buffer overflow in C:</i>
	</br>
The error message "*** stack smashing detected ***: \<unknown> terminated" indicates that the program has encountered a stack-based buffer overflow,
	which occurs when more data is written into a buffer than it can hold. This causes the excess data to overwrite adjacent memory locations on the stack,
	potentially leading to program termination or security vulnerabilities. The "Aborted (core dumped)" part of the message indicates that the program was
	forcibly terminated by the operating system, and a core dump file was created for debugging purposes. To fix this issue, the program's code needs to be carefully
	reviewed to identify and address the buffer overflow, ensuring proper handling of buffer sizes and bounds checking to prevent writing beyond allocated memory.
	This will improve the program's stability and security.
	</br>
	</br>
<i>Buffer overflow in Python:</i>
</br>
The error message "Traceback (most recent call last): File 'Overflow.py', line 3, in <module> buffer[i]=7 IndexError: list assignment index out of range"
	indicates that an IndexError occurred in the Python program "Overflow.py".
</br>
The error has occurred on line 3 of the program. The programme is trying to assign a value (7) to an index (i) in a list (buffer) that is out of range.
	The index value provided is greater than or equal to the length of the list.
</br>
To fix the issue, the index that is being uses to access the list falls within its valid range. The index value needs to be less than the length of the list (taking into account zero-based indexing).
</br>
Once pip has been installed here is what happens.
</br>
1. "Building wheels for collected packages: typed-ast": The installation process is building "wheels" (a binary distribution format in Python) for the package named "typed-ast".
	This step is necessary to compile the package for the specific platform.
</br>
2. "Running setup.py bdist_wheel for typed-ast ...done": The setup.py script for the "typed-ast" package is being executed to create the wheel distribution,
	and it was completed successfully.
</br>
3. "Stored in directory: /home/codio/.cache/pip/wheels/a0/57/54/6c037af50d26591734cd3024784a7caab619474ea4a7c22ab4": The resulting wheel file for the "typed-ast"
	package was stored in the specified directory.
</br>
4. "Successfully built typed-ast": The "typed-ast" package was built successfully.
</br>
5. "Installing collected packages": The installation process is now proceeding to install the packages listed after this line.
</br>
6. The subsequent lines list the packages that are being installed. Each line shows the name of the package followed by its version number.
</br>
Based on the provided output, the installation process was successful, and the listed packages have been installed with their respective versions.
</br>
</br>
	<strong>Unit 4: Exploring Programming Language Concepts</strong>
</br>
</br>
<i>What is ReDOS and what part do ‘Evil Regex’ play?</i>
</br>
ReDOS (Regular Expression Denial of Service) is a vulnerability that occurs when a particular regular expression pattern is susceptible to exponential backtracking.
	It can lead to significant performance degradation or even denial of service due to the excessive amount of time and resources consumed by the regex engine to process certain inputs.
	ReDOS vulnerabilities can be exploited by crafting input strings that trigger the worst-case scenario for the regex pattern,
	causing the regex engine to spend an excessive amount of time evaluating the input (Larson & Kirk, 2016).
</br>
What are the common problems associated with the use of regex? How can these be mitigated?
</br>
"Evil Regex" refers to regular expressions that are intentionally crafted to exploit ReDOS vulnerabilities.
	These malicious regex patterns are designed to cause excessive backtracking, leading to denial of service or severe performance degradation when processing specific inputs (Larson & Kirk, 2016).
</br>
</br>
<i>How and why could regex be used as part of a security solution?</i>
	</br>
Common problems associated with the use of regex include:
</br>
   a. Exponential Backtracking: Certain regex patterns can exhibit exponential backtracking, causing the regex engine to spend an inordinate amount of time processing input strings.
</br>
   b. Catastrophic Backtracking: This occurs when a regex pattern has multiple valid interpretations for a given input, leading to inefficient matching and performance issues.
</br>
   c. Inadequate Input Validation: Improper use of regex can lead to insufficient input validation, allowing potentially malicious input to bypass security checks.
</br>
   d. Complexity and Maintainability: Complex regex patterns can be challenging to understand, debug, and maintain over time, leading to code readability issues and potential bugs.
</br>
	</br>
<i>To mitigate these problems, the following steps can be taken:</i>
</br>
   a. Optimize Regex Patterns: Analyse and optimise regex patterns to avoid excessive backtracking and catastrophic backtracking.
	This involves structuring patterns to minimise ambiguity and unnecessary complexity.
</br>
   b. Input Length Limitations: Enforce input length limitations and implement proper input validation to prevent long inputs from triggering excessive backtracking.
</br>
   c. Use Regex Engines with Backtracking Limits: Employ regex engines or libraries that provide backtracking
	limits or timeouts to prevent regex evaluation from consuming excessive resources.
</br>
   d. Thorough Testing: Perform comprehensive testing of regex patterns with various input scenarios, including edge cases and long inputs,
	to identify and address potential performance issues.
</br>
	</br>
<i>4. Regex can be used as part of a security solution for various purposes:</i>
</br>
   a. Input Validation and Filtering: Regex can be employed to validate and filter user inputs,
	protecting against common security vulnerabilities such as injection attacks (e.g., SQL injection, cross-site scripting) by ensuring that inputs meet expected patterns.
</br>
   b. Log Analysis and Intrusion Detection: Regex can be used to analyse logs and detect patterns indicative of security breaches or intrusion attempts.
	This can aid in identifying and responding to potential security incidents.
</br>
   c. Data Sanitisation: Regex can help sanitize and scrub sensitive information, such as personally identifiable information (PII) or credit card numbers,
	from data sets to protect privacy and comply with data protection regulations.
</br>
   d. Web Application Firewall (WAF) Rules: Regex patterns can be used in web application firewalls to create rules for
	blocking or allowing specific types of requests based on predefined patterns, helping to protect against common web application attacks.
</br>
However, it's important to note that regex should be used judiciously and with caution. Proper validation,
	testing, and understanding of regex patterns are essential to avoid introducing vulnerabilities or performance issues.
</br>
References:
</br>
<i>Larson, E. and Kirk, A. (2016) ‘Generating evil test strings for regular expressions’,
	2016 IEEE International Conference on Software Testing, Verification and Validation (ICST) [Preprint]. doi:10.1109/icst.2016.29.</i>
</br>
	</br>
	<b>The Producer-Consumer Mechanism Questions</b>
	</br>
	<i>1.	How is the queue data structure used to achieve the purpose of the code?</i></br>
</br>
	In the provided code, the `Queue` data structure from the `queue` module is used to facilitate communication and coordination between the producer and consumer threads. 
	</br>
	</br>
	<i>2.	What is the purpose of q.put(I)?</i></br>
	</br>
	`q.put(i)`: The purpose of `q.put(i)` is to add an item (`i`) to the queue. In this code, the producer thread (`producer()`) iterates over a range of numbers and puts each number into the queue (`q`).
	This simulates producing items and adding them to the shared queue for consumption by the consumer threads.
	</br>
	</br>
	<i>3.	What is achieved by q.get()?</i></br>
	</br>
	`q.get()`: The function `q.get()` is used by the consumer threads to retrieve an item from the queue. In this code, the consumer threads (`consumer()`)
	continuously fetch items from the queue (`q`) using `q.get()`. The consumer threads will block if the queue is empty until an item becomes available for consumption.
	</br>
	</br>
	<i>4.	What functionality is provided by q.join()?</i></br>
</br>
	`q.join()`: The `q.join()` function is used to block until all items in the queue have been processed and marked as done using `q.task_done()`.
	This ensures that the producer waits until all items have been consumed and processed by the consumer threads before proceeding.
	In other words, the `q.join()` call blocks the main thread until the queue is empty and all tasks are marked as done.
	</br>
	</br>
	<i>5.	Extend this producer-consumer code to make the producer-consumer scenario available in a secure way.</br>
	What technique(s) would be appropriate to apply?</i></br>
	</br>
	By using the `Queue` data structure, the producer and consumer threads can safely communicate and coordinate their actions.
	The producer adds items to the queue, and the consumer threads retrieve items from the queue, process them, and mark them as done.
	The `Queue` ensures that the operations are synchronised and thread-safe, preventing potential race conditions or conflicts between the threads.
	</br>
	</br>

from threading import Thread</br>
from queue import Queue</br>
from multiprocessing import Lock</br>
</br>
q = Queue()</br>
final_results = []</br>
lock = Lock()</br>
</br>
def producer():</br>
    for i in range(100):</br>
        q.put(i)</br>
 </br>       
def consumer():</br>
    while True:</br>
        number = q.get()</br>
        result = (number, number**2)</br>
        with lock:</br>
            final_results.append(result)</br>
        q.task_done()</br>
</br>
  </br>      
def run_producer_consumer():</br>
    # Start consumer threads</br>
    for i in range(5):</br>
        t = Thread(target=consumer)</br>
        t.daemon = True</br>
        t.start()</br>
    </br>
    producer()</br>
   </br> 
    # Wait for all tasks to be processed</br>
    q.join()</br>
    </br>
    # Print final results</br>
    print(final_results)</br>
</br>
</br>
In the extended code, the following techniques have been applied:</br>
</br>
1. **Threading**: The code utilises the `Thread` class from the `threading` module to implement concurrent execution.
	The `consumer` function is executed in multiple threads, allowing for parallel processing of items from the queue.</br>
</br>
2. **Queue**: The `Queue` class from the `queue` module is used to facilitate communication and synchronisation between the producer and consumer threads.
	The `Queue` provides a thread-safe way to store and retrieve items, ensuring proper coordination in the producer-consumer scenario.</br>
</br>
3. **Locking**: The `Lock` class from the `multiprocessing` module is used to create a lock object (`lock`) that is used to protect access to the `final_results` list.
	By using the `with lock` statement, only one thread can append a result to the `final_results` list at a time, preventing potential conflicts or race conditions.</br>
</br>
	</br>
	<strong>Unit 5: An Introduction to Testing</strong></br>
	</br>
	<b>Exploring the Cyclomatic Complexity’s Relevance Today</b></br>
	</br>
	<i>The Cyclomatic Complexity is commonly considered in modules on testing the validity of code design today.
	However, in your opinion, should it be? Does it remain relevant today? Specific to the focus of this module, is it relevant in our quest to develop secure software?</i>
	</br>
	</br>
	Cyclomatic Complexity is a metric used to measure code complexity, it is relevant in code design for maintainability and testability purposes.
	High complexity can make code harder to understand, maintain, and test thoroughly. Considering Cyclomatic Complexity helps identify areas that may benefit from refactoring or improved design.
	</br>
	However, Cyclomatic Complexity has limitations. It focuses solely on structural complexity and doesn't capture other dimensions of complexity.
	Additionally, the appropriate complexity threshold varies depending on the context, making it a context-dependent metric.
	The advised number of levels is less than ten and over ten it is encouraged to refracture the code.
	</br>
	Regarding security, while reducing complexity can contribute to improved security by enhancing code manageability and analysis,
	Cyclomatic Complexity alone does not directly address security concerns. Developing secure software requires a holistic approach that considers factors such as input validation,
	authentication, secure communication, and adherence to secure coding practices.
	</br>
	In conclusion, Cyclomatic Complexity remains relevant as a code quality metric, aiding maintainability and testability.
	However, it should not be the sole determinant of code design decisions. Developing secure software necessitates considering a wider range of
	security-specific factors alongside Cyclomatic Complexity analysis.
	</br>
	</br>
References:
</br>
<i>Antinyan, V. et al. (2017) Evaluating code complexity triggers, use of complexity measures and the influence of code complexity on maintenance time.
	Empirical software engineering : an international journal. [Online] 22 (6), 3057–3087.</i>
</br>
<i>Shepperd, M. (1988) A Critique of Cyclomatic Complexity as a Software Metric, Software Engineering Journal.</i>
</br>
</br>

	<strong>Unit 6: Using Linters to Support Python Testing</strong>
	</br>
	</br>
	<b>Exploring Linters to Support Testing in Python: Question 1</b>
	</br>
	When running the equivalence.py the message in the terminal is -   File "equivalence.py", line 14
	</br>
	"""</br>
	^</br>
	IndentationError: expected an indented block</br>
	codio@matrixponcho-carbontemple:~/workspace$</br>
	</br>
	The error message indicates an "IndentationError" in the code.</br>
	Correct indentation is crucial for the structure and readability of the code.</br>
	The error specifically states that an indented block was expected after line 14, which is the line containing the triple double-quoted string (""").</br>
	To resolve this error, there needs to be an indented block of code following the line with the triple double-quoted string.</br>
	</br>
	Below is the corrected code with the triple double-quoted string indented and on the correct line.</br>
</br>
def equivalence_partition(iterable, relation):</br>
    """</br>
    Partitions a set of objects into equivalence classes</br>
</br>
    Args:</br>
        iterable: collection of objects to be partitioned</br>
        relation: equivalence relation. I.e. relation(o1,o2) evaluates to True</br>
            if and only if o1 and o2 are equivalent</br>
</br>
    Returns: classes, partitions</br>
        classes: A sequence of sets. Each one is an equivalence class</br>
        partitions: A dictionary mapping objects to equivalence classes</br>
    """</br>
    classes = []</br>
    partitions = {}</br>
    for o in iterable:  # for each object</br>
        # find the class it is in</br>
        found = False</br>
        for c in classes:</br>
            if relation(next(iter(c)), o):  # is it equivalent to this class?</br>
                c.add(o)</br>
                partitions[o] = c</br>
                found = True</br>
                break</br>
        if not found:  # it is in a new class</br>
            classes.append(set([o]))</br>
            partitions[o] = classes[-1]</br>
    return classes, partitions</br>
</br>
</br>
def equivalence_enumeration(iterable, relation):</br>
    """</br>
    Partitions a set of objects into equivalence classes</br>
</br>
    Same as equivalence_partition() but also numbers the classes.</br>
</br>
    Args:</br>
        iterable: collection of objects to be partitioned</br>
        relation: equivalence relation. I.e. relation(o1,o2) evaluates to True</br>
            if and only if o1 and o2 are equivalent</br>
</br>
    Returns: classes, partitions, ids</br>
        classes: A sequence of sets. Each one is an equivalence class</br>
        partitions: A dictionary mapping objects to equivalence classes</br>
        ids: A dictionary mapping objects to the indices of their equivalence classes</br>
    """</br>
    classes, partitions = equivalence_partition(iterable, relation)</br>
    ids = {}</br>
    for i, c in enumerate(classes):</br>
        for o in c:</br>
            ids[o] = i</br>
    return classes, partitions, ids</br>
</br>
def check_equivalence_partition(classes, partitions, relation):</br>
    """Checks that a partition is consistent under the relationship"""</br>
    for o, c in partitions.items():</br>
        for _c in classes:</br>
            assert (o in _c) ^ (not _c is c)</br>
    for c1 in classes:</br>
        for o1 in c1:</br>
            for c2 in classes:</br>
                for o2 in c2:</br>
                    assert (c1 is c2) ^ (not relation(o1, o2))</br>
</br>

def test_equivalence_partition():</br>
    relation = lambda x, y: (x - y) % 4 == 0</br>
    classes, partitions = equivalence_partition(</br>
        range(-3, 5),</br>
        relation</br>
    )</br>
    check_equivalence_partition(classes, partitions, relation)</br>
    for c in classes:</br>
        print(c)</br>
    for o, c in partitions.items():</br>
        print(o, ':', c)</br>
</br>

if __name__ == '__main__':</br>
    test_equivalence_partition()</br>
</br>

<b>Exploring Linters to Support Testing in Python: Question 2</b></br>
</br>
This is the response when running the code pylintTest.py:</br>
codio@matrixponcho-carbontemple:~/workspace$ python3 pylintTest.py</br>
  File "pylintTest.py", line 26</br>
    print encoded</br>
                ^</br>
SyntaxError: Missing parentheses in call to 'print'. Did you mean print(encoded)?</br>
codio@matrixponcho-carbontemple:~/workspace$ python3 pylintTest.py</br>
Traceback (most recent call last):</br>
  File "pylintTest.py", line 7, in <module></br>
    choice = raw_input("would you like to encode or decode?")</br>
NameError: name 'raw_input' is not defined</br>
codio@matrixponcho-carbontemple:~/workspace$ python3 pylintTest.py</br>
</br>
Line 26 original  – print encoded</br>
Correction - print (encoded)</br>
</br>
Needed the correct parentheses</br>
</br>
Line 7  original – choice = raw-input ("would you like to encode or decode?")</br>
word = raw-input ("Please enter text"))</br>
</br>
Correction – </br>
choice = input ("would you like to encode or decode?")</br>
word = input ("Please enter text")</br>
</br>
Raw input was is not defined in the code only input</br>
</br>
</br>
<b>Exploring Linters to Support Testing in Python: Question 3</b></br>
</br>
SyntaxError: Missing parentheses in call to 'print'. Did you mean print(encoded)?</br>
codio@matrixponcho-carbontemple:~/workspace$</br>
</br>
When you install pip install flake8 it shows the above message in the terminal when ran, it suggests what could be</br>
	  wrong with the code unlike the pylint it just tells you there is an error on the line of code that needs fixed.</br>

Next when looking over the metricTest.py code there are multiple corrections between syntax errors and indentation.</br>
	  Firstly, I went through and removed the numbers at the beginning of each line of code, then I went through correcting syntax and indentation</br>
	  with the help of the flake 8.</br>
	  </br>
	  </br>
<b>Exploring Linters to Support Testing in Python: Question 4</b></br>
</br>

<i>Run mccabe on sums.py. What is the result?</i></br>
</br>
codio@matrixponcho-carbontemple:~/workspace$ pip3 install mccabe</br>
Collecting mccabe</br>
  Using cached https://files.pythonhosted.org/packages/27/1a/1f68f9ba0c207934b35b86a8ca3aad8395a3d6dd7921c0686e23853ff5a9/mccabe-0.7.0-py2.py3-none-any.whl</br>
Installing collected packages: mccabe</br>
Successfully installed mccabe-0.7.0</br>
codio@matrixponcho-carbontemple:~/workspace$ python3 sums.py</br>
Everything passed</br>
</br>
This is what is fed back through the terminal but when mccabe is ran it has fixed the problem as shown in the above code.</br>
</br>
Run mccabe on sums2.py. What is the result?</br>
</br>
codio@matrixponcho-carbontemple:~/workspace$ pip3 install mccabe</br>
Collecting mccabe</br>
  Using cached https://files.pythonhosted.org/packages/27/1a/1f68f9ba0c207934b35b86a8ca3aad8395a3d6dd7921c0686e23853ff5a9/mccabe-0.7.0-py2.py3-none-any.whl</br>
Installing collected packages: mccabe</br>
Successfully installed mccabe-0.7.0</br>
codio@matrixponcho-carbontemple:~/workspace$ python3 sums2.py</br>
Traceback (most recent call last):</br>
  File "sums2.py", line 12, in <module></br>
    test_sum_tuple()</br>
  File "sums2.py", line 8, in test_sum_tuple</br>
    assert sum((1, 2, 2)) == 6, "Should be 6"</br>
AssertionError: Should be 6</br>
For the next question the above is output in the terminal and using mccabe it tells me the assertation error for the number is incorrect</br>
	  and they do not add up to 6, I corrected the line 8, I changed the number to a 3 so it looked like this assert sum((1, 2, 3)) == 6, "Should be 6"</br>
</br>
	  </br>
<b>What are the contributors to the cyclomatic complexity in each piece of code?</b></br>
</br>
Here is a breakdown of the cyclomatic complexity contributors for code sums2.py:</br>
</br>
test_sum() function:</br>
There are no decision points or branching structures within this function.</br>
The function consists of a single assertion statement.</br>
test_sum_tuple() function:</br>
Similar to test_sum(), there are no decision points or branching structures within this function.</br>
The function also consists of a single assertion statement.</br>
if __name__ == "__main__": block:</br>
This block is not a function but rather the entry point of the script.</br>
There are no decision points or branching structures within this block.</br>
The block simply calls the test_sum() and test_sum_tuple() functions and prints a message.</br>
Overall, the cyclomatic complexity of this code is low because there are no explicit decision points or branching structures.</br>
	  The code primarily focuses on asserting the correctness of the sums and displaying a success message if all assertions pass.</br>
</br>
<i>Overall Complexity for pylintTest.py:</i></br>
</br>
The code contains nested structures, including an outer if statement and an inner for loop.</br>
The presence of nested decision points and branching structures contributes to the overall cyclomatic complexity.</br>
Outer if statement (lines 6-9):</br>
The if statement introduces a decision point based on the user's choice.</br>
The presence of the if statement increases the cyclomatic complexity.</br>
Inner for loop (lines 10-19):</br>
The for loop iterates over each character in the input word.</br>
Within the loop, there is an if-else structure that checks if the current character is a space or not.</br>
The if-else structure adds decision points and branches, contributing to the cyclomatic complexity.</br>
Nested if statements (lines 12-18):</br>
Within the inner for loop, there are nested if statements.</br>
The first if statement checks if the current character is a space and handles it differently.</br>
The second if statement, which is incorrectly indented, checks if the choice is "decode" and performs decoding operations.</br>
	  However, due to the incorrect indentation, it is nested within the first if statement, causing a logical issue.</br>

</br>
<i>Overall Complexity for metricTest.py:</i></br>
</br>
Code with the fn function:</br>
The function fn consists of a single statement (return x + y).</br>
There are no decision points or branching structures within this function.</br>
Therefore, the cyclomatic complexity of this function is low.</br>
Code with the find_optimal_route_to_my_office_from_home function:</br>
The initial check if d <= 30 introduces a decision point.</br>
The if-elif structure on lines 11-23 adds complexity due to multiple branches.</br>
Nested if statements within the outer if statement on lines 11-18 further contribute to the cyclomatic complexity.</br>
The presence of multiple levels of nesting and different conditions increases the overall cyclomatic complexity of the function.</br>
Code with the C and D classes:</br>
The C class does not have any methods defined, so it does not introduce additional complexity.</br>
The D class inherits from C and overrides the __init__, f, and g methods.</br>
The overridden f method introduces a decision point with an if-else structure.</br>
The overridden g method also introduces a decision point with an if-else structure.</br>
The presence of these decision points in the overridden methods contributes to the cyclomatic complexity of the D class.</br>
Overall, the cyclomatic complexity varies across the different pieces of code. Functions or methods with decision points, branching structures,</br>
	and nested conditions tend to have higher cyclomatic complexity. On the other hand, functions or methods with linear control
	flow and no decision points have lower cyclomatic complexity.</br>
</br>
	</br>
	<strong>Unit 7: Introduction to Operating Systems</strong></br>
	</br>
	<b>What is an Ontology?</b></br>
	</br>
	<i>What do you understand about the ontology that has been presented for your reading this week?
	Could you attempt to define an ontology that would be relevant to the system that you are designing for the summative assessment?</i></br>
	</br>
	An ontology is a formal and explicit representation of concepts and relationships within a specific domain or knowledge area.
	It serves as a structured framework for organising knowledge and capturing the essential entities, properties, and relationships that exist within the domain.
	In other words, an ontology provides a systematic way to model and describe the concepts, categories, and relationships relevant to a particular subject area.
	It defines the vocabulary and rules for how entities and their attributes relate to each other, offering a shared understanding and a common language for communication and knowledge representation.
	By defining an ontology, one can establish a formal and structured representation of knowledge that enables effective knowledge sharing, reasoning, and analysis within a specific domain.</br>
	</br>
	
	Ontologies are typically created and maintained through a systematic and iterative process involving the following steps:</br>
	</br>
	1. Domain Understanding: Gain a deep understanding of the domain.</br>
	2. Conceptualisation: Identify and define core concepts and entities.</br>
	3. Ontology Specification: Use a formal ontology language to specify the ontology's structure.</br>
	4. Knowledge Acquisition: Gather knowledge from various sources.</br>
	5. Ontology Population: Populate the ontology with instances and data.</br>
	6. Evaluation and Refinement: Evaluate and refine the ontology based on feedback and validation.</br>
	7. Documentation: Document the ontology's purpose, structure, and usage guidelines.</br>
	8. Maintenance and Evolution: Update and maintain the ontology as new knowledge and requirements emerge.</br>
	9. Collaboration and Community Engagement: Engage with others to enhance the ontology through collaboration and community contributions.</br>
	</br>
	The process of creating and maintaining ontologies requires a combination of domain expertise, knowledge engineering techniques, and iterative refinement based on feedback and real-world usage.
	It is an ongoing effort to ensure that the ontology remains relevant, accurate, and useful within its intended domain.</br>
	</br>
	Listed below are the ontologies for the online shop system and the key concepts:</br>
	</br>
	1. Product: Represents a product available for sale in the online shop. It may have properties such as name, description, price, and availability.</br>
	2. Category: Represents a category or classification for organising products. Products can be associated with one or more categories.</br>
	3. Customer: Represents a customer who can browse and make purchases in the online shop. It may have properties such as name, email, and address.</br>
	4. Order: Represents an order placed by a customer. It contains information such as the customer who placed the order, the products ordered, quantities, and total price.</br>
	5. Cart: Represents a shopping cart where customers can add products before proceeding to checkout. It contains information about the products, quantities, and the associated customer.</br>
	6. Payment: Represents the payment information for an order, including payment method, billing address, and transaction details.</br>
	7. Shipping: Represents the shipping information for an order, including the shipping address, delivery method, and tracking details.</br>
	8. Review: Represents customer reviews or ratings for products. It may include properties such as the rating, comments, and the associated product and customer.</br>
	</br>
	These are the core concepts that will be included in my ontology for the online shop system. Each concept will have associated properties,
	relationships, and constraints depending on the specific requirements for the online shop system.</br>
	</br>
	In summary, ontologies have practical applications in knowledge management, data integration, intelligent systems, and domain-specific applications.
	They deliver benefits such as improved knowledge organisation, semantic interoperability, intelligent information retrieval, decision support, data integration, collaboration, and future-proofing capabilities.</br>
	</br>
	<b>References:</b></br>
	</br>
	Arnaut, W. et al. (2010) ‘OWL-SOA: A service oriented architecture ontology useful during development time and independent from implementation technology’,
	in 2010 Fourth International Conference on Research Challenges in Information Science (RCIS). [Online]. 2010 IEEE. pp. 523–532.</br>
	</br>
	Saltzer, J. H. & Schroeder, M. D. (1975) The protection of information in computer systems. Proceedings of the IEEE. [Online] 63 (9), 1278–1308.</br>
	</br>
</br>

	<b>Distributed API</b></br>
	</br>
	<i>Question 1:
	</br>
	Run the API.py code. Take a screenshot of the terminal output.
	What command did you use to compile and run the code?</i>
</br>
	To access the API endpoints I used a web browser and made requests programmatically with Postman.
	</br>
	The server is running locally on port 5000, which can be accessed by navigating to http://127.0.0.1:5000/user/<name> in your web browser or by making HTTP requests to that URL.
		</br>
		The endpoints available in this code are:
		</br>
		GET /user/<name>: Retrieves information about a user by their name.
			</br>
			POST /user/<name>: Creates a new user with the specified name, age, and occupation.
				</br>
				PUT /user/<name>: Updates the information (age and occupation) of an existing user.
					</br>
					DELETE /user/<name>: Deletes a user by their name.
						</br>

	<i>Question 2:
	</br>
	Run the following command at the terminal prompt: w3m http://127.0.0.1:5000/user/Ann
	</br>
	What happens when this command is run, and why?</i>
	</br>
	<img src="images/API7.png" alt="API"class="fit-page">
</br>
</br>
	<i>Question 3: Run the following command at the terminal prompt: w3m http://127.0.0.1:5000/user/Adam
		What happens when this command is run, and why?</i>
</br>
	<img src="images/API72.png" alt="API"class="fit-page">
	</br>
</br>
	<i>Question 4: What capability is achieved by the flask library?</i>
	</br>
	The code demonstrates the use of the Flask library to create a simple RESTful API.
	The capabilities achieved by the Flask library in this code include:</br>
</br>
Web Application Framework:</br>
Flask serves as a web application framework, providing a structure for building web applications and APIs in Python.
</br>
Routing:</br>
Flask allows you to define routes using decorators (@app.route) to associate URL patterns with specific functions.
In this code, the User resource is associated with the endpoint /user/<string:name>.
</br>
RESTful API Development:</br>
Flask, along with the Flask-RESTful extension, supports the development of RESTful APIs.
The code defines HTTP methods (GET, POST, PUT, DELETE) for managing user information (CRUD operations).
</br>
HTTP Request Handling:</br>
Flask provides tools for handling HTTP requests. The reqparse.RequestParser class is used to parse and validate request arguments.
This is crucial for processing data sent in the request body or URL parameters.
</br>
HTTP Response Handling:</br>
Flask facilitates the creation of HTTP responses.
Depending on the request, the code returns data along with appropriate status codes (e.g., 200 for success, 404 for not found, 400 for a bad request).
</br>
Dynamic URL Routing:</br>
Flask allows dynamic URL routing by including variable parts in the URL pattern (e.g., <string:name>).
These variable parts can be extracted and used as parameters in the corresponding view function.
</br>
Development Server:</br>
Flask includes a development server (app.run(debug=True)) that allows you to test your application locally during development.
The server automatically reloads when changes are made to the code.
</br>
JSON Serialisation:</br>
The code uses Flask to automatically serialise Python dictionaries into JSON format when returning responses.
This is a common feature in building APIs.</br>
In summary, the Flask library in this code enables the creation of a RESTful API with capabilities for handling HTTP requests,
defining routes, managing resources, and providing a simple development server.</br>
	</br>

	<b>Exploring a simple Python shell</b></br>
	</br>
	
	<img src="images/U71.png" alt="Python Shell"class="fit-page">
	
	<img src="images/U72.png" alt="Python Shell"class="fit-page">

	<img src="images/U73.png" alt="Python Shell"class="fit-page">
	
	<i>1. What are the two main security vulnerabilities with your shell?</i></br>
	</br>
	Command Injection:
	</br>
	The shell takes user input directly for commands without proper validation or sanitisation.
	This makes it vulnerable to command injection attacks where a user could input malicious commands.
	</br>
	</br>
	2. What is one recommendation you would make to increase the security of the shell?
	</br>
	Input Validation:
	</br>
	The ADD command takes user input for two numbers without proper validation.
	If a user enters something other than a number, it may lead to unexpected behaviour or errors.
	One recommendation to increase the security of the shell is to use proper input validation and command sanitisation.
	</br>
	</br>
	3. Add a section to your e-portfolio that provides a (pseudo)code example of changes you would make to the shell to improve its security.

</br>
	<img src="images/U74.png" alt="Python Shell"class="fit-page">
	<img src="images/U75.png" alt="Python Shell"class="fit-page">
	</br>

	</br>
	<strong>Unit 8: Cryptography and Its Use in Operating Systems</strong>
	</br>

	
	</br>
	<strong>Unit 9: Developing an API for a Distributed Environment</strong>
	</br>	</br>
	<img src="images/U81.png" alt="Discussion Post"class="fit-page">
	<img src="images/U82.png" alt="Discussion Post"class="fit-page">
	<img src="images/U83.png" alt="Discussion Post"class="fit-page">
	<img src="images/U84.png" alt="Discussion Post"class="fit-page">
	<img src="images/U85.png" alt="Discussion Post"class="fit-page">
	<img src="images/U86.png" alt="Discussion Post"class="fit-page">
</br>
	</br>
	<strong>Unit 10: From Distributed Computing to Microarchitectures</strong>
	</br>
	<strong>Unit 11: Future trends in Secure Software Development</strong>
	</br>
	<strong>Unit 12: The Great Tanenbaum-Torvalds Debate Revisited</strong>
	</br>
</div>
